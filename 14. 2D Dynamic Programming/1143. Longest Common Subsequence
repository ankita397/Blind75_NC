https://leetcode.com/problems/longest-common-subsequence/description/
https://www.youtube.com/watch?v=4Urd0a0BNng&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=19


//Recursion
//TC = O(2 ^ (n+m))
//SC = O(m+n)
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int n = text1.length();
        int m = text2.length();
        return lcs(text1, text2, n, m);
    }

    public int lcs(String s1, String s2, int i, int j){
        //Base case
        if(i==0 || j==0){
            return 0;
        }

        if(s1.charAt(i-1) == s2.charAt(j-1)){ // check if the last characters match
            return 1 + lcs(s1, s2, i-1, j-1);
        }else{
            return Math.max(lcs(s1,s2, i-1,j) , lcs(s1,s2, i,j-1)) ;
        }
    }
}

//Memoization
//TC = O(n*m)
//SC = O(n*m) + O(n+m)
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int n = text1.length();
        int m = text2.length();
        int[][] dp = new int[n+1][m+1];
        for(int i = 0; i <= n; i++){
            for(int j = 0; j <= m; j++){
                dp[i][j] = -1;
            }
        }
        return lcs(text1, text2, n, m, dp);
    }

    public int lcs(String s1, String s2, int i, int j, int[][] dp){
        //Base case
        if(i==0 || j==0){
            return 0;
        }

        if(dp[i][j] != -1){
            return dp[i][j];
        }

        if(s1.charAt(i-1) == s2.charAt(j-1)){ // check if the last characters match
            return dp[i][j] = 1 + lcs(s1, s2, i-1, j-1, dp);
        }else{
            return dp[i][j] = Math.max(lcs(s1,s2, i-1,j, dp) , lcs(s1,s2, i,j-1, dp)) ;
        }
    }
}

//Tabulation
//TC = O(n*m)
//SC = O(n*m)
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int n = text1.length();
        int m = text2.length();
        int[][] dp = new int[n+1][m+1];
        //Base case
        for(int i = 0; i <= n; i++){
            dp[i][0] = 0;
        }
        //Base case
        for(int j = 0; j <= m; j++){
            dp[0][j] = 0;
        }
        for(int i = 1; i <= n; i++){
             for(int j = 1; j <= m; j++){
                if(text1.charAt(i-1) == text2.charAt(j-1)){ // check if the last characters match
                    dp[i][j] = 1 + dp[i-1][j-1];
                }else{
                    dp[i][j] = Math.max(dp[i-1][j] , dp[i][j-1]) ;
                }
             }
        }  
        return dp[n][m];
    }
}

//Space Optimization
//TC = O(n*m)
//SC = O(m)
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int n = text1.length();
        int m = text2.length();
        int[] prev = new int[m+1]; // m+1 because the length of this 1D array depends on columns (m)
        //Base case for 0th column is not needed as only 1 row i there for prev array. 
        //So we loop over column index 'm'
        
        //Base case
        for(int j = 0; j <= m; j++){
            prev[j] = 0;
        }
        for(int i = 1; i <= n; i++){
             int[] curr = new int[m+1];
             for(int j = 1; j <= m; j++){
                if(text1.charAt(i-1) == text2.charAt(j-1)){ // check if the last characters match
                    curr[j] = 1 + prev[j-1];
                }else{
                    curr[j] = Math.max(prev[j] , curr[j-1]) ;
                }
             }
             prev = curr;
        }  
        return prev[m];
    }
}
