https://leetcode.com/problems/merge-k-sorted-lists/description/

//Brute Force - exactly same as 21. Merge Two Sorted Lists

//TC = O(KN) + O(M log M) + O(M) , K = lists.length = size of the given list of LLs, M = each linked list size, 
//M = N*K (total no of elements in the nodeList

//SC = O(M)+O(M) where M is the total number of nodes from all lists, N1 + N2 + N3...+Nk. O(M) to store all the nodes of both the lists in an 
//external array and another O(N) to create a new combined list.

class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ArrayList<Integer> nodeList = new ArrayList<Integer>();
        // for(ListNode node: lists){
        //     while(node != null){
        //         nodeList.add(node.val);
        //         node = node.next;
        //     }
        // }
        for(int i = 0; i < lists.length; i++){//O(k) where k = lists.length = size of the given list of LLs
            ListNode temp =lists[i];
            while(temp != null){//O(n) where each linked list is of size n
                nodeList.add(temp.val);
                temp = temp.next;
            }
        }
        Collections.sort(nodeList);//O(nlogn)
        ListNode mergedList = convertArrToLinkedList(nodeList);//O(N)

        return mergedList;
    }

    private ListNode convertArrToLinkedList(ArrayList<Integer> nodeList){//O(n)
        //Create a dummy node to serve as the dummy head of the new LL
        ListNode dummyNode = new ListNode(-1);

        //Use a temp node for traversal
        ListNode temp = dummyNode;

        for(int i = 0; i < nodeList.size(); i++){
            // Create a new node with the array element
            temp.next = new ListNode(nodeList.get(i));
            // Move the temporary pointer to the newly created node
            temp = temp.next;
        }
        // Return the linked list starting from the next of the dummy node
        return dummyNode.next;  
    }
}

//Better - similar to 21. Merge Two Sorted Lists  => sort in-place

INTUITION

//TC = N1+N2 + (N1+N2+N3) + (N1+N2+N3+N4) = N(1+2+...+k) = N * ((K * K+1)/2) ~ O(n^3) in worst case
//SC = O(1) - We just use the existing linked lists and link them in sorted manner. No extra space is used

class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        // If there are no lists, return null
        if (lists.length == 0) return null;
    
        // Initialize the merged list as the first list in the array
        ListNode head = lists[0];
    
        // Iterate through each list starting from the second list
        for (int i = 1; i < lists.length; i++) {
            // Merge the current merged list (head) with the next list in the array
            // and update head to the result of this merge
            head = merge2Lists(head, lists[i]);
        }
    
        // Return the final merged list
        return head;
    }

    private ListNode merge2Lists(ListNode list1, ListNode list2){// N1+N2 + (N1+N2+N3) + (N1+N2+N3+N4) = N(1+2+...+k) = N * ((K * K+1)/2)
       // Create a dummy node to serve as the head of the merged list
        ListNode dummyNode = new ListNode(-1);
        ListNode temp = dummyNode; //to traverse and link

        // Traverse both lists simultaneously
        while(list1 != null && list2 != null){
            // Compare elements of both lists and link the smaller node to the merged list
            if(list1.val < list2.val){
                temp.next = list1;
                list1 = list1.next;
            }else{
                temp.next = list2;
                list2 = list2.next;
            }
            // Move the temporary pointer to the next node - traverse
            temp = temp.next;
        }
        // Either list1 has nodes left or list2 has nodes left
        // If any list still has remaining elements, append them to the merged list
        if(list1 != null){
            temp.next = list1;
        }else if(list2 != null){
            temp.next = list2;
        }
        // Return the merged list starting from the next of the dummy node since dummy node is not that actual head.. second node is the actual start of the linked list
        return dummyNode.next;
    }
}
