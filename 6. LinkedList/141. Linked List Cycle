https://leetcode.com/problems/linked-list-cycle/description/

https://www.youtube.com/watch?v=wiOo4DC5GGA

//Brute force - Hashing

//TC = O(n) - since we visit each node at most once(while loop goes till through the entire length of the LL) and 
//hashmap operations take O(1) in java
//SC = O(n), due to the space needed to store up to n nodes in the HashMap

public class Solution {
    public boolean hasCycle(ListNode head) {
        //Use HashMap to remember if the node has been encountered already
        Map<ListNode, Integer> map = new HashMap<ListNode, Integer>();
        ListNode temp = head;
        while(temp != null){
            if(map.containsKey(temp)){//check if the current node is already present in our map, then we know it has a cycle
                return true;
            }
            map.put(temp, 1);// Keep storing the nodes in the map till we find a node is already present in our map
            temp = temp.next;
        }
        return false;
    }
}

//Optimal - 2 pointers

//INTUITION:
- Move slow pointer by 1 and fast pointer by 2. 
- If slow and fast pointer collide at any node((or point to same node) then we know the LL has a cycle.
- They will eventually collide for sure  because the distance between fast and slow (not slow and fast) reduces at each step. 
- That is the reason, 
    - we move fast by 2 positions towards slow 
    - we move slow by 1 position away from fast 
    so the distance(d) from fast to slow reduces by 1 each time (fast becomes closer to slow by 1 position).
- This ensures the distance d reduces as: d → d-1 → d-2 … until it becomes 0 (collision).
- This only happens when the linked list has a cycle, which is why fast moves 2 steps toward slow and slow moves 1 step.

//TC = O(N), where N is the number of nodes in the linked list. 
This is because in the worst-case scenario, the fast pointer, which moves quicker, will either reach the end of the list (in case of no loop)
or meet the slow pointer (in case of a loop) in a linear time relative to the length of the list.

The key insight into why this is O(N) and not something slower is that each step of the algorithm reduces the distance between the fast
and slow pointers (when they are in the loop) by one. Therefore, the maximum number of steps needed for them to meet is proportional to the 
number of nodes in the list.

//SC = O(1) : The code uses only a constant amount of additional space, regardless of the linked list's length. 

public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        // Since fast pointer moves two steps at a time 
        //if LL has even no of nodes, then 1st condition will be executed and 
        //if LL has odd no of nodes, the 2nd condition will get executed
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if(slow == fast){//slow and fast collide here
                return true;
            }
        }
        return false;
    }
}
