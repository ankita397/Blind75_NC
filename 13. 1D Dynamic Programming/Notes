IMP : 
For recursion to space optimization flow - Striver
For choice diagram for recursion and dp matrix - Aditya Verma [At least go through 1st video in each pattern of DP] 

DP = Enhanced recursion [Parent of DP is Recursion]
DP = Recursion + Overlapping subproblems
Memoization - Top-down (recursion + memoization) = RC + dp array
Tabulation - Bottom-up (iterative table) - only dp array
Space-optimized (1D or 2D compression) - variables

Recurrence
1. Express everything in terms of index
2. Try all possible ways
3. Find max length or count, etc
4. Base case - Think of the smallest valid input (IMPORTANT)

Recursion :
1. If your problem definition involves reducing (like factorial or Fibonacci) → start recursion from n-1.
        Climbing Stairs
        Coin Change (minimum coins)
        Edit Distance (Levenshtein Distance)
        Longest Increasing Subsequence (LIS)
        Knapsack Problem
        Partition Equal Subset Sum
        Minimum Path Sum in a grid
        House Robber
        Decode Ways (number of ways to decode a string)
2. If your problem involves building from the beginning (like printing or generating sequences) → start from 0 (or the smallest meaningful case).
    1D DP
        Longest Increasing Subsequence (LIS)
        Maximum Subarray Sum (Kadane’s Algorithm)
        Climbing Stairs / Fibonacci (bottom-up)
        House Robber
        Coin Change (number of ways)
        Minimum Cost to Reach End (like min cost climbing stairs)
    2D DP
        Longest Common Subsequence (LCS)
        Edit Distance
        Unique Paths in a Grid
        Minimum Path Sum in a Grid
        0/1 Knapsack (tabulation version)

Recursion to Memoization :
1. declare dp array - 1D or 2D depends on the number of changing parameters.
2. size of dp array depends on the changing parameters - Eg: 2 changes -> 2D dp -> size should be enough to accomodate the changing params.
        If n is size of array and that is the only changing param, then it will be 1D dp array - size dp[n+1] - as we need 
        to store values till n. 
        Think of it like having n floors in a building, and you're making a chart to record how to get to each one. 
        Since you start on floor 0, your chart needs space for 0, 1, 2, ..., n. That’s n+1 floors!
3. if(dp[ind] != -1) return dp[ind]; // if dp[ind] has been computed already, return the same
4. assign dp[ind] to the result and return [Eg: return dp[ind] = maxLen]

Tabulation :
1. Handle base case
2. Express the changing parameters as loop
        - opposite manner (make sure to follow coordinate shift)
4. Copy the recurrence and make sure to follow coordinate shift

BASE CASE : 
        whenever recursion is started from n-1, our base case will always be for index 0 - tabulation from 0 to n-1
        whenever recursion is started from 0, our base case will always be for index n - tabulation from n-1 to 0


