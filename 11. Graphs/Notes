#If array list is given - ArrayList<ArrayList<Integer>> edges

boolean[] vis = new boolean[n];
List<ArrayList<Integer>> adj = new ArrayList<>();
for(int i = 0; i < n; i++){
    adj.add(new ArrayList<Integer>());
}
for(int i = 0; i < m; i++){//undirected graph
    adj.get(edges.get(i).get(0)).add(edges.get(i).get(1)); //u to v
    adj.get(edges.get(i).get(1)).add(edges.get(i).get(0));//v to u
}

#If array is given - int[][] edges

boolean vis[] = new boolean[n];
ArrayList<ArrayList<Integer>> adj = new ArrayList<>(n);
 for (int i = 0; i < n; i++) {
    adj.add(new ArrayList<>());
}

for(int i=0; i<m; i++){
    adj.get(edges[i][0]).add(edges[i][1]);
    adj.get(edges[i][1]).add(edges[i][0]);
}


//DFS

void dfs( ArrayList<ArrayList<Integer>> adj, boolean vis[], int node)
{
    vis[node] =true;
    for(int neighbor : adj.get(node)){
        if(!vis[neighbor]){
                cnt++;
               dfs(adj,vis, neighbor);
            }
    }
}

//BFS

int st=0;
Queue<Integer> q = new LinkedList<>();
vis[node]=true;
q.add(node);
while(!q.isEmpty()){
    int curr=q.poll();
    for(int neighbor : adj.get(curr)){
        if(!vis[neighbor]){
            vis[neighbor] = true;
            cnt++;
            q.add(nei);
        }
    }
}
