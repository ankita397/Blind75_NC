#If array list is given

boolean[] vis = new boolean[n];
List<ArrayList<Integer>> adj = new ArrayList<>();
for(int i = 0; i < n; i++){
    adj.add(new ArrayList<Integer>());
}
for(int i = 0; i < m; i++){//undirected graph
    adj.get(edges.get(i).get(0)).add(edges.get(i).get(1)); //u to v
    adj.get(edges.get(i).get(1)).add(edges.get(i).get(0));//v to u
}

#If array is given

boolean vis[] = new boolean[n];
ArrayList<ArrayList<Integer>> adj = new ArrayList<>(n);
 for (int i = 0; i < n; i++) {
    adj.add(new ArrayList<>());
}

for(int i=0; i<m; i++){
    adj.get(edges[i][0]).add(edges[i][1]);
    adj.get(edges[i][1]).add(edges[i][0]);
}


//DFS

void dfs( ArrayList<ArrayList<Integer>> adj, boolean vis[], int st)
{
    vis[st] =true;
    for(int nei : adj.get(st)){
        if(!vis[nei]){
                cnt++;
               dfs(adj,vis, nei);
            }
    }
}

//BFS

int st=0;
Queue<Integer> q = new LinkedList<>();
vis[st]=true;
q.add(st);
while(!q.isEmpty()){
    int curr=q.poll();
    for(int nei : adj.get(curr)){
        if(!vis[nei]){
            vis[nei] = true;
            cnt++;
            q.add(nei);
        }
    }
}
