1. Constant Window
  a. Move left and right by same value to keep window size same.
  b. right < n-1, since r++ with make it go out of bounds and here we keep window constant
2. Longest subarray/sumstring where <condition>
  a. Brute Force - Generate all substrings 
    for(i = 0; i < n; i++){  
      for(j = i; j < n; j++){
        ...
      }
    }
  b. Two pointer and sliding window 
    i. Shrink or move left when condition is invalid
    ii. Expand or move right when condition is valid
      while(r < n){
        <invalid condition>
          left++
        ...
        <valid condition>
          calculate maxLen/minLen
          keep track of statring and ending index of substring(in case we need the substring as answer)
        right++;
      }
    iii. If for (ii), TC = O(2N) and only maxLen or minLen is asked and not the string, then we can compromise on substring and optimise more.
      -> Keep shrinking window or moving left to keep the maxLen or minLen same, ignoring the current substring till we get valid condition.
          And then starting expanding(move right) again.

General :
1. Shrink or move left when condition is invalid
2. Expand or move right when condition is valid
3. length always means length of substring from left to right - length = right-left+1
4. Code the invalid confition first.
