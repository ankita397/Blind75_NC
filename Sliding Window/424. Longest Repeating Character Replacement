https://leetcode.com/problems/longest-repeating-character-replacement/description/
//i/p - AABABBA, k = 2
//o/p - 5
//brute force
//Generate all substrings and get the max length
//keep i constant and move j to right 
//Figure out how many chars to convert 
//Look to minimise conversions - in substring AABAB, A is 3 times and B is 2 times - so convert B's to A's - do not change 
//char appraring max no of times
//No of conversions = length - maxFreq(char)

//TC = O(n^2)
class Solution {
    public int characterReplacement(String s, int k) {
        int n = s.length();
        int maxLen = 0;
        int maxCharFreq = 0;
        int length = 0;
        for(int i = 0; i < n; i++){
            int freq[] = new int[26];
            for(int j = i; j < n; j++){
                freq[s.charAt(j)-'A']++;// increament freq of character appearing
                length = j-i+1;
                maxCharFreq = Math.max(maxCharFreq,freq[s.charAt(j)-'A']);// find the max occuring character's length in current substring
                //in substring A , maxCharFreq = 1, length = 1 => 1-1 <=k , so maxLen = 1
                //in substring A , maxCharFreq = 2, length = 2 => 2-2 <=k , so maxLen = 2
                //in substring B , maxCharFreq = 2, length = 3 => 3-2 <=k , so maxLen = 3
                //in substring A , maxCharFreq = 3, length = 4 => 4-3 <=k , so maxLen = 4
                //in substring B , maxCharFreq = 3, length = 5 => 5-3 <=k , so maxLen = 4
                //in substring B , maxCharFreq = 3, length = 6 => 6-3 <=k , break - i++
                if(length - maxCharFreq <= k){
                    maxLen = Math.max(maxLen,length);
                }else{
                    break;
                }
            }
        }
        return maxLen;
    }
}

//Optimal approach : Sliding window with 2 pointers

//TC = O(n)
//SC = O(1)

class Solution {
    public int characterReplacement(String s, int k) {
        int n = s.length();
        int maxLen = 0;
        int maxCharFreq = 0;
        int left = 0, right = 0;
        int freq[] = new int[26];
        while(right < n){
            int length = 0;
            freq[s.charAt(right)-'A']++;
            length = right-left+1;
            maxCharFreq = Math.max(maxCharFreq, freq[s.charAt(right)-'A']);
            if(length-maxCharFreq > k){//invalid - so slide the window by moving left
                freq[s.charAt(left)-'A']--;
                // no point in reducing maxCharFreq as it will not give us a better maxLen
                //Eg: AABABBA - substring AABAB - here we already get maxCharFreq = 3 and length = 5 which is the maxLen till now. Now next maxLen will have to 6 or more. It cannot be lesser.
                //So reducing maxCharFreq can never satisfy the the condition length-maxCharFreq <= k . Suppose, we reduce maxCharFreq to 2 after sliding window to substring ABAB, if we need length 6 then 6-2 <= k(2) = false always
                //maxCharFreq = 0;
                left++;
            }
            if(length - maxCharFreq <= k){// update maxLen when condition satisfies
                maxLen = Math.max(maxLen,length);
            }
            right++;
        }
        return maxLen;
    }
}
