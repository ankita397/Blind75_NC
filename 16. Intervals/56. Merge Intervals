https://leetcode.com/problems/merge-intervals/description/
https://www.youtube.com/watch?v=IexN60k62jo


//Brute force - skip learning this - too complicated
//TC = O(nlogn) + O(n) - sort and The outer loop runs O(n) times. The inner loop also runs through intervals, 
//but overall, each interval is processed at most once or skipped
//SC = O(n)
class Solution {
    public int[][] merge(int[][] intervals) {
        int n = intervals.length;  // Total number of intervals

        // Example input:
        // intervals = { {1, 3}, {2, 6}, {8, 10}, {15, 18} }

        // Step 1: Sort intervals by start time
        // Arrays.sort(intervals, new Comparator<int[]>() {
        //     public int compare(int[] a, int[] b) {
        //         return a[0] - b[0];
        //     }
        // });
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

        List<int[]> ans = new ArrayList<>();

        // Step 2: Loop through each interval
        // i = 0 → start = 1, end = 3
        // i = 1 → start = 2, end = 6
        // i = 2 → start = 8, end = 10
        // i = 3 → start = 15, end = 18
        for (int i = 0; i < n; i++) {
            int start = intervals[i][0];
            int end = intervals[i][1];

           // Skip if current interval is inside the last merged interval
            // Example:
            // last merged interval in ans = [1, 6]
            // current interval = [2, 6]
            // since 6 (current end) <= 6 (last merged end), skip it
            if (!ans.isEmpty() && end <= ans.get(ans.size() - 1)[1]) {
                continue;
            }

            // Step 3: Merge overlapping intervals
            for (int j = i + 1; j < n; j++) {
                if (intervals[j][0] <= end) {
                    // Overlapping interval found, extend the 'end'

                    // Example walkthrough for i = 0:
                    // Current interval = [1, 3]
                    // j = 1 → arr[1] = [2, 6]
                    // Since 2 <= 3 (start of next ≤ current end), they overlap
                    // Update end = max(3, 6) = 6 → merged interval becomes [1, 6]

                    // If there were more overlapping intervals, this loop continues merging

                    end = Math.max(end, intervals[j][1]);
                } else {
                    // No overlap, break the loop
                    break;
                }
            }

            // Add the merged interval to the answer list
            ans.add(new int[]{start, end});

            /*
            Step 3 detailed example:
            -----------------------
            i = 0:
            start = 1, end = 3
            Check j = 1:
                arr[1][0] = 2 <= 3 → overlapping
                end = max(3, 6) = 6
            No more overlaps at j=2 because 8 > 6
            So merged interval is [1, 6]

            i = 1:
            arr[1] = [2, 6] inside [1, 6] → skip

            i = 2:
            start = 8, end = 10
            Check j = 3:
                arr[3][0] = 15 > 10 → no overlap
            Add [8, 10]

            i = 3:
            start = 15, end = 18
            No next intervals → Add [15, 18]
            */
        }

        // Convert list to array and return
        return ans.toArray(new int[ans.size()][]);
    }
}

//Optimal - Learn this only
//TC = O(nlogn) - sort and single loop
//SC = O(n)
import java.util.*;

class Solution {
    public int[][] merge(int[][] intervals) {
        int n = intervals.length;

        // Step 1: Sort intervals by their start time
        // Example: intervals = [[1,3], [2,6], [8,10], [15,18]]
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        // After sorting: [[1,3], [2,6], [8,10], [15,18]]

        List<int[]> ans = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            // Step 2: If ans is empty OR current interval does not overlap with last merged interval, add it
            // i=0: ans empty → add [1,3]
            // ans = [[1,3]]
            if (ans.isEmpty() || intervals[i][0] > ans.get(ans.size() - 1)[1]) {
                ans.add(intervals[i]);
            } else {
                // Step 3: Overlapping intervals - extend the end of last merged interval if needed
                // i=1: current = [2,6], last merged = [1,3]
                // since 2 <= 3 (overlap), update end of last merged to max(3,6) = 6
                // ans = [[1,6]]
                ans.get(ans.size() - 1)[1] = Math.max(ans.get(ans.size() - 1)[1], intervals[i][1]);
            }
            // i=2: current = [8,10], last merged = [1,6]
            // 8 > 6 (no overlap), add [8,10]
            // ans = [[1,6], [8,10]]
            // i=3: current = [15,18], last merged = [8,10]
            // 15 > 10 (no overlap), add [15,18]
            // ans = [[1,6], [8,10], [15,18]]
        }

        // Step 4: Convert the list to array and return the result
        return ans.toArray(new int[ans.size()][]);
    }
}
